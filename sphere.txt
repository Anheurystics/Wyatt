import "utils.txt";

buffer buf;
buffer scrn;

texture2D target;

vert basic(vec3 pos, vec3 normal, vec3 color) {
	mat4 model;
	mat4 normal_model;
	mat4 view;
	mat4 proj;

	func main() {
		vec4 modelPos = model * [pos, 1.0];

		FinalPosition = proj * view * modelPos;
		Pos = modelPos.xyz;
		Normal = mat3(normal_model) * normal;
		Color = color;
	}
}(vec4 FinalPosition, vec3 Pos, vec3 Normal, vec3 Color)

frag basic(vec3 Pos, vec3 Normal, vec3 Color) {
	vec3 lightPos;
	func main() {
		vec3 toLight = normalize(lightPos - Pos);
		float diffuse = max(0.0, dot(toLight, normalize(Normal)));
		vec3 litColor = Color * (diffuse * [1.0, 1.0, 1.0]);
		FinalColor = [litColor, 1.0];
	}
}(vec4 FinalColor)

vert screen(vec3 pos) {
	func main() {
		FinalPosition = [pos, 1.0];
		UV = (pos.xy * 0.5) + 0.5;
	}
}(vec4 FinalPosition, vec2 UV)

frag screen(vec2 UV) {
	texture2D tex;

	func main() {
		FinalColor = texture(tex, UV) * 0.99;
	}
}(vec4 FinalColor)

func generate_quad(float size, vec3 normal, vec3 right, int resolution) {
	vec3 up = normal % right;
	float half_size = size * 0.5;
	vec3 topleft = (-right + up) * half_size;	

	list vertices = {};
	for(i in 0, resolution + 1, 1) {
		for(j in 0, resolution + 1, 1) {
			vec3 v = (topleft + (-up * size * i / resolution) + (right * size * j / resolution));
			vertices += v;
		}
	}

	list result = {};
	for(i in 0, resolution, 1) {
		for(j in 0, resolution, 1) {
			vec3 v0 = vertices[(i * (resolution + 1)) + j];
			vec3 v1 = vertices[(i * (resolution + 1)) + j + 1];
			vec3 v2 = vertices[((i + 1) * (resolution + 1)) + j];
			vec3 v3 = vertices[((i + 1) * (resolution + 1)) + j + 1];

			result += v2, v1, v0, v2, v3, v1;
		}
	 }

	return result;
}

func generate_cube(float size, int resolution) {
	list vertices = {};
	
	var normals = {[0,0,1],[0,0,-1],[1,0,0],[-1,0,0],[0,1,0],[0,-1,0]};
	var rights =  {[1,0,0],[-1,0,0],[0,0,-1],[0,0,1],[1,0,0],[1,0,0]};

	for(i in 0,|normals|,1) {
		var quad = generate_quad(size, normals[i], rights[i], resolution);
		for(j in 0,|quad|,1) {
			quad[j] += normals[i] * 0.5;
			vertices += quad[j];
		}
	}

	return vertices;
}

func generate_sphere(float radius, int resolution) {
	var cube = generate_cube(1.0, resolution);
	for(i in 0,|cube|,1) {
		cube[i] = normalize(cube[i]) * radius;
	}
	return cube;
}

func init(){
	var cube = generate_sphere(1.0, 6);
	for(i in 0,|cube|,1) {
		buf.pos += cube[i];
		buf.normal += normalize(cube[i]);
		buf.color += [1, 0.3, 0.3];
	}

	basic.lightPos = [4, 4, 4];
	basic.model = mat4_identity();
	basic.normal_model = mat4_transpose(mat4_inverse(basic.model));
	basic.view = mat4_lookat([0, 0, 4], [0, 0, 0], [0, 1, 0]);
	basic.proj = mat4_perspective(pi() / 4, 1, 0.1, 1000);

	float screen_size = 2;
	var quad = generate_quad(screen_size, [0.0, 0.0, 1.0], [1.0, 0.0, 0.0], 1);
	for(i in 0,|quad|,1) {
		vec3 v = quad[i];
		scrn.pos += v;
	}
}

func loop(){
	clear;
	draw buf to target using basic;

	clear;
	screen.tex = target;
	draw scrn;
}
