import "utils.txt";

buffer buf;

vert basic(vec3 pos) {
	mat4 model;
	mat4 view;
	mat4 proj;

	func main() {
		FinalPosition = proj * view * model * [pos, 1.0];
	}
}(vec4 FinalPosition)

frag basic() {
	vec3 color;
	func main() {
		FinalColor = [color, 1.0];
	}
}(vec4 FinalColor)	

func generate_quad(float size, vec3 normal, vec3 right, int resolution) {
	vec3 up = normal % right;
	float half_size = size * 0.5;
	vec3 topleft = (-right + up) * half_size;	

	list vertices = {};
	for(i in 0, resolution + 1, 1) {
		for(j in 0, resolution + 1, 1) {
			vec3 v = (topleft + (-up * size * i / resolution) + (right * size * j / resolution));
			vertices += v;
		}
	}

	list result = {};
	for(i in 0, resolution, 1) {
		for(j in 0, resolution, 1) {
			vec3 v0 = vertices[(i * (resolution + 1)) + j];
			vec3 v1 = vertices[(i * (resolution + 1)) + j + 1];
			vec3 v2 = vertices[((i + 1) * (resolution + 1)) + j];
			vec3 v3 = vertices[((i + 1) * (resolution + 1)) + j + 1];

			result += v2, v1, v0, v2, v3, v1;
		}
	 }

	return result;
}

func generate_cube(float size, int resolution) {
	list vertices = {};
	
	var normals = {[0,0,1],[0,0,-1],[1,0,0],[-1,0,0],[0,1,0],[0,-1,0]};
	var rights =  {[1,0,0],[-1,0,0],[0,0,-1],[0,0,1],[1,0,0],[1,0,0]};

	for(i in 0,|normals|,1) {
		var quad = generate_quad(size, normals[i], rights[i], resolution);
		for(j in 0,|quad|,1) {
			quad[j] += normals[i] * 0.5;
			vertices += quad[j];
		}
	}

	return vertices;
}

func generate_sphere(float radius, int resolution) {
	var cube = generate_cube(1.0, resolution);
	for(i in 0,|cube|,1) {
		cube[i] = normalize(cube[i]) * radius;
	}
	return cube;
}

func init(){
	var cube = generate_sphere(1.0, 6);
	for(i in 0,|cube|,1) {
		buf.pos += cube[i];
	}

	basic.color = [1.0, 0.3, 0.3];
	basic.model = mat4_identity();
	basic.view = mat4_lookat([0, 0, 4], [0, 0, 0], [0, 1, 0]);
	basic.proj = mat4_perspective(pi() / 4, 1, 0.1, 1000);
}

func loop(){
	draw buf;
}
